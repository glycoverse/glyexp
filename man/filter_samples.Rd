% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dplyr-filter.R
\name{filter_samples}
\alias{filter_samples}
\alias{filter_variables}
\title{Filter Samples or Variables of an Experiment}
\usage{
filter_samples(exp, ...)

filter_variables(exp, ...)
}
\arguments{
\item{exp}{An \code{\link[=experiment]{experiment()}}.}

\item{...}{<\code{\link[rlang:args_data_masking]{data-masking}}> Expression to filter samples or variables.
passed to \code{\link[dplyr:filter]{dplyr::filter()}} internally.}
}
\value{
An new \code{\link[=experiment]{experiment()}} object.
}
\description{
Getting a subset of an \code{\link[=experiment]{experiment()}} by filtering samples or variables.

The same syntax as \code{\link[dplyr:filter]{dplyr::filter()}} is used.
For example, to get a subset of an experiment keeping only "HC" samples,
use \code{filter_samples(exp, group == "HC")}.
This actually calls \code{dplyr::filter()} on the sample information tibble
with condition \code{group == "HC"},
and then updates the expression matrix accordingly.

If no samples or variables are left after filtering, an error is thrown.
}
\examples{
library(magrittr)

# Create a toy experiment for demonstration
expr_mat <- matrix(1:25, nrow = 5)
colnames(expr_mat) <- paste0("S", 1:5)
rownames(expr_mat) <- paste0("V", 1:5)
sample_info <- tibble::tibble(
  sample = paste0("S", 1:5),
  group = c("A", "A", "A", "B", "B")
)
var_info <- tibble::tibble(
  variable = paste0("V", 1:5),
  type = c("X", "X", "Y", "Y", "Y")
)
exp <- experiment(expr_mat, sample_info, var_info)

# Filter samples
sub_exp_1 <- filter_samples(exp, group == "A")
get_sample_info(sub_exp_1)
get_expr_mat(sub_exp_1)

# Filter variables
sub_exp_2 <- filter_variables(exp, type == "X")
get_var_info(sub_exp_2)
get_expr_mat(sub_exp_2)

# Use pipe
sub_exp_3 <- exp \%>\%
  filter_samples(group == "A") \%>\%
  filter_variables(type == "X")
get_sample_info(sub_exp_3)
get_var_info(sub_exp_3)
get_expr_mat(sub_exp_3)

}
